/*
OpenPay API

super charge your subscription management.

API version: 1.2.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package getopenpay

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// BillingMeterEventsAPIService BillingMeterEventsAPI service
type BillingMeterEventsAPIService service

type ApiCreateBillingMeterEventRequest struct {
	ctx context.Context
	ApiService *BillingMeterEventsAPIService
	createBillingMeterEventRequest *CreateBillingMeterEventRequest
}

func (r ApiCreateBillingMeterEventRequest) CreateBillingMeterEventRequest(createBillingMeterEventRequest CreateBillingMeterEventRequest) ApiCreateBillingMeterEventRequest {
	r.createBillingMeterEventRequest = &createBillingMeterEventRequest
	return r
}

func (r ApiCreateBillingMeterEventRequest) Execute() (*BillingMeterEventExternal, *http.Response, error) {
	return r.ApiService.CreateBillingMeterEventExecute(r)
}

/*
CreateBillingMeterEvent Create Billing Meter Event

A billing meter event represents a customer’s usage of a product. Meter events are used to
bill a customer based on their usage. Meter events are associated with billing meters,
which define the shape of the event’s payload and how those events are aggregated for billing.
Every event is identified by an unique identifier, same identifier can not be used again.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBillingMeterEventRequest
*/
func (a *BillingMeterEventsAPIService) CreateBillingMeterEvent(ctx context.Context) ApiCreateBillingMeterEventRequest {
	return ApiCreateBillingMeterEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BillingMeterEventExternal
func (a *BillingMeterEventsAPIService) CreateBillingMeterEventExecute(r ApiCreateBillingMeterEventRequest) (*BillingMeterEventExternal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BillingMeterEventExternal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingMeterEventsAPIService.CreateBillingMeterEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/billing/meter-events/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createBillingMeterEventRequest == nil {
		return localVarReturnValue, nil, reportError("createBillingMeterEventRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createBillingMeterEventRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBillingMeterEventSummariesRequest struct {
	ctx context.Context
	ApiService *BillingMeterEventsAPIService
	listBillingMeterEventSummariesRequest *ListBillingMeterEventSummariesRequest
}

func (r ApiListBillingMeterEventSummariesRequest) ListBillingMeterEventSummariesRequest(listBillingMeterEventSummariesRequest ListBillingMeterEventSummariesRequest) ApiListBillingMeterEventSummariesRequest {
	r.listBillingMeterEventSummariesRequest = &listBillingMeterEventSummariesRequest
	return r
}

func (r ApiListBillingMeterEventSummariesRequest) Execute() (*ListResponseBillingMeterSummary, *http.Response, error) {
	return r.ApiService.ListBillingMeterEventSummariesExecute(r)
}

/*
ListBillingMeterEventSummaries List Billing Meter Event Summaries

A billing meter event summary represents an aggregated view of a customer’s billing meter
events within a specified timeframe. It indicates how much usage was accrued by
a customer for that period.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBillingMeterEventSummariesRequest
*/
func (a *BillingMeterEventsAPIService) ListBillingMeterEventSummaries(ctx context.Context) ApiListBillingMeterEventSummariesRequest {
	return ApiListBillingMeterEventSummariesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListResponseBillingMeterSummary
func (a *BillingMeterEventsAPIService) ListBillingMeterEventSummariesExecute(r ApiListBillingMeterEventSummariesRequest) (*ListResponseBillingMeterSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListResponseBillingMeterSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingMeterEventsAPIService.ListBillingMeterEventSummaries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/billing/meter-events/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.listBillingMeterEventSummariesRequest == nil {
		return localVarReturnValue, nil, reportError("listBillingMeterEventSummariesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.listBillingMeterEventSummariesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
