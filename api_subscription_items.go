/*
OpenPay API

super charge your subscription management.

API version: 1.2.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package getopenpay

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SubscriptionItemsAPIService SubscriptionItemsAPI service
type SubscriptionItemsAPIService service

type ApiCreateSubscriptionItemRequest struct {
	ctx context.Context
	ApiService *SubscriptionItemsAPIService
	createSubscriptionItemRequest *CreateSubscriptionItemRequest
}

func (r ApiCreateSubscriptionItemRequest) CreateSubscriptionItemRequest(createSubscriptionItemRequest CreateSubscriptionItemRequest) ApiCreateSubscriptionItemRequest {
	r.createSubscriptionItemRequest = &createSubscriptionItemRequest
	return r
}

func (r ApiCreateSubscriptionItemRequest) Execute() (*SubscriptionItemExternal, *http.Response, error) {
	return r.ApiService.CreateSubscriptionItemExecute(r)
}

/*
CreateSubscriptionItem Create Subscription Item

Adds a new item to an existing subscription. No existing items will be changed or replaced.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSubscriptionItemRequest
*/
func (a *SubscriptionItemsAPIService) CreateSubscriptionItem(ctx context.Context) ApiCreateSubscriptionItemRequest {
	return ApiCreateSubscriptionItemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubscriptionItemExternal
func (a *SubscriptionItemsAPIService) CreateSubscriptionItemExecute(r ApiCreateSubscriptionItemRequest) (*SubscriptionItemExternal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionItemExternal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionItemsAPIService.CreateSubscriptionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subscription-items/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createSubscriptionItemRequest == nil {
		return localVarReturnValue, nil, reportError("createSubscriptionItemRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createSubscriptionItemRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSubscriptionItemRequest struct {
	ctx context.Context
	ApiService *SubscriptionItemsAPIService
	subscriptionItemId string
	deleteSubscriptionItemRequest *DeleteSubscriptionItemRequest
}

func (r ApiDeleteSubscriptionItemRequest) DeleteSubscriptionItemRequest(deleteSubscriptionItemRequest DeleteSubscriptionItemRequest) ApiDeleteSubscriptionItemRequest {
	r.deleteSubscriptionItemRequest = &deleteSubscriptionItemRequest
	return r
}

func (r ApiDeleteSubscriptionItemRequest) Execute() (*DeleteSubscriptionItemResponse, *http.Response, error) {
	return r.ApiService.DeleteSubscriptionItemExecute(r)
}

/*
DeleteSubscriptionItem Delete Subscription Item

Deletes an item from the subscription. Removing a subscription item
 from a subscription will not cancel the subscription.
Default behaviour is to remove the subscription item at time of
 renewing the subscription at next billing cycle. You can override
 the behaviour by setting cancel_at_end as False.
After successful call to this method with drop_at_end as True,
 if you want to clear the flag, use update call with drop_at_end as False.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subscriptionItemId Unique identifier of the subscription_item.
 @return ApiDeleteSubscriptionItemRequest
*/
func (a *SubscriptionItemsAPIService) DeleteSubscriptionItem(ctx context.Context, subscriptionItemId string) ApiDeleteSubscriptionItemRequest {
	return ApiDeleteSubscriptionItemRequest{
		ApiService: a,
		ctx: ctx,
		subscriptionItemId: subscriptionItemId,
	}
}

// Execute executes the request
//  @return DeleteSubscriptionItemResponse
func (a *SubscriptionItemsAPIService) DeleteSubscriptionItemExecute(r ApiDeleteSubscriptionItemRequest) (*DeleteSubscriptionItemResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteSubscriptionItemResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionItemsAPIService.DeleteSubscriptionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subscription-items/{subscription_item_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"subscription_item_id"+"}", url.PathEscape(parameterValueToString(r.subscriptionItemId, "subscriptionItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteSubscriptionItemRequest == nil {
		return localVarReturnValue, nil, reportError("deleteSubscriptionItemRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteSubscriptionItemRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubscriptionItemRequest struct {
	ctx context.Context
	ApiService *SubscriptionItemsAPIService
	subscriptionItemId string
}

func (r ApiGetSubscriptionItemRequest) Execute() (*SubscriptionItemExternal, *http.Response, error) {
	return r.ApiService.GetSubscriptionItemExecute(r)
}

/*
GetSubscriptionItem Get Subscription Item

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subscriptionItemId Unique identifier of the subscription_item.
 @return ApiGetSubscriptionItemRequest
*/
func (a *SubscriptionItemsAPIService) GetSubscriptionItem(ctx context.Context, subscriptionItemId string) ApiGetSubscriptionItemRequest {
	return ApiGetSubscriptionItemRequest{
		ApiService: a,
		ctx: ctx,
		subscriptionItemId: subscriptionItemId,
	}
}

// Execute executes the request
//  @return SubscriptionItemExternal
func (a *SubscriptionItemsAPIService) GetSubscriptionItemExecute(r ApiGetSubscriptionItemRequest) (*SubscriptionItemExternal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionItemExternal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionItemsAPIService.GetSubscriptionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subscription-items/{subscription_item_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"subscription_item_id"+"}", url.PathEscape(parameterValueToString(r.subscriptionItemId, "subscriptionItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSubscriptionItemsRequest struct {
	ctx context.Context
	ApiService *SubscriptionItemsAPIService
	subscriptionItemQueryParams *SubscriptionItemQueryParams
}

func (r ApiListSubscriptionItemsRequest) SubscriptionItemQueryParams(subscriptionItemQueryParams SubscriptionItemQueryParams) ApiListSubscriptionItemsRequest {
	r.subscriptionItemQueryParams = &subscriptionItemQueryParams
	return r
}

func (r ApiListSubscriptionItemsRequest) Execute() (*ListResponseSubscriptionItemExternal, *http.Response, error) {
	return r.ApiService.ListSubscriptionItemsExecute(r)
}

/*
ListSubscriptionItems List Subscription Items

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListSubscriptionItemsRequest
*/
func (a *SubscriptionItemsAPIService) ListSubscriptionItems(ctx context.Context) ApiListSubscriptionItemsRequest {
	return ApiListSubscriptionItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListResponseSubscriptionItemExternal
func (a *SubscriptionItemsAPIService) ListSubscriptionItemsExecute(r ApiListSubscriptionItemsRequest) (*ListResponseSubscriptionItemExternal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListResponseSubscriptionItemExternal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionItemsAPIService.ListSubscriptionItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subscription-items/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscriptionItemQueryParams == nil {
		return localVarReturnValue, nil, reportError("subscriptionItemQueryParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscriptionItemQueryParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSubscriptionItemRequest struct {
	ctx context.Context
	ApiService *SubscriptionItemsAPIService
	subscriptionItemId string
	updateSubscriptionItemRequest *UpdateSubscriptionItemRequest
}

func (r ApiUpdateSubscriptionItemRequest) UpdateSubscriptionItemRequest(updateSubscriptionItemRequest UpdateSubscriptionItemRequest) ApiUpdateSubscriptionItemRequest {
	r.updateSubscriptionItemRequest = &updateSubscriptionItemRequest
	return r
}

func (r ApiUpdateSubscriptionItemRequest) Execute() (*SubscriptionItemExternal, *http.Response, error) {
	return r.ApiService.UpdateSubscriptionItemExecute(r)
}

/*
UpdateSubscriptionItem Update Subscription Item

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subscriptionItemId Unique identifier of the subscription_item.
 @return ApiUpdateSubscriptionItemRequest
*/
func (a *SubscriptionItemsAPIService) UpdateSubscriptionItem(ctx context.Context, subscriptionItemId string) ApiUpdateSubscriptionItemRequest {
	return ApiUpdateSubscriptionItemRequest{
		ApiService: a,
		ctx: ctx,
		subscriptionItemId: subscriptionItemId,
	}
}

// Execute executes the request
//  @return SubscriptionItemExternal
func (a *SubscriptionItemsAPIService) UpdateSubscriptionItemExecute(r ApiUpdateSubscriptionItemRequest) (*SubscriptionItemExternal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionItemExternal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionItemsAPIService.UpdateSubscriptionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subscription-items/{subscription_item_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"subscription_item_id"+"}", url.PathEscape(parameterValueToString(r.subscriptionItemId, "subscriptionItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateSubscriptionItemRequest == nil {
		return localVarReturnValue, nil, reportError("updateSubscriptionItemRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateSubscriptionItemRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
