/*
OpenPay API

super charge your subscription management.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package getopenpay

import (
	"encoding/json"
	"fmt"
)

// ObjectName the model 'ObjectName'
type ObjectName string

// List of ObjectName
const (
	OBJECTNAME_ACCOUNT ObjectName = "account"
	OBJECTNAME_API_TOKEN ObjectName = "api_token"
	OBJECTNAME_CHARGE ObjectName = "charge"
	OBJECTNAME_CHECKOUT_SESSION ObjectName = "checkout_session"
	OBJECTNAME_CHECKOUT_SESSION_ITEM ObjectName = "checkout_session_item"
	OBJECTNAME_COUPON ObjectName = "coupon"
	OBJECTNAME_CREDIT_NOTE ObjectName = "credit_note"
	OBJECTNAME_CREDIT_NOTE_ITEM ObjectName = "credit_note_item"
	OBJECTNAME_CUSTOMER ObjectName = "customer"
	OBJECTNAME_CUSTOMER_BALANCE_TRANSACTION ObjectName = "customer_balance_transaction"
	OBJECTNAME_DELIVERY_ATTEMPT ObjectName = "delivery_attempt"
	OBJECTNAME_DISCOUNT ObjectName = "discount"
	OBJECTNAME_DISPUTE ObjectName = "dispute"
	OBJECTNAME_EVENT ObjectName = "event"
	OBJECTNAME_INVITE ObjectName = "invite"
	OBJECTNAME_INVOICE_ITEM_DISCOUNT ObjectName = "invoice_item_discount"
	OBJECTNAME_INVOICE ObjectName = "invoice"
	OBJECTNAME_INVOICE_DISCOUNT ObjectName = "invoice_discount"
	OBJECTNAME_INVOICE_ITEM ObjectName = "invoice_item"
	OBJECTNAME_PAYMENT_INTENT ObjectName = "payment_intent"
	OBJECTNAME_PAYMENT_LINK ObjectName = "payment_link"
	OBJECTNAME_PAYMENT_LINK_LINE_ITEM ObjectName = "payment_link_line_item"
	OBJECTNAME_PAYMENT_METHOD ObjectName = "payment_method"
	OBJECTNAME_TOKENIZED_CARD_PAYMENT_METHOD ObjectName = "tokenized_card_payment_method"
	OBJECTNAME_PAYMENT_METHOD_MAPPING ObjectName = "payment_method_mapping"
	OBJECTNAME_PAYMENT_PROCESSOR ObjectName = "payment_processor"
	OBJECTNAME_PORTAL_SESSION ObjectName = "portal_session"
	OBJECTNAME_PRICE ObjectName = "price"
	OBJECTNAME_PRICE_TIER ObjectName = "price_tier"
	OBJECTNAME_PRODUCT ObjectName = "product"
	OBJECTNAME_PRODUCT_FAMILY ObjectName = "product_family"
	OBJECTNAME_PROMOTION_CODE ObjectName = "promotion_code"
	OBJECTNAME_REFUND ObjectName = "refund"
	OBJECTNAME_SETUP_INTENT ObjectName = "setup_intent"
	OBJECTNAME_SUBSCRIPTION ObjectName = "subscription"
	OBJECTNAME_SUBSCRIPTION_ITEM ObjectName = "subscription_item"
	OBJECTNAME_TAX_INTEGRATION ObjectName = "tax_integration"
	OBJECTNAME_USER ObjectName = "user"
	OBJECTNAME_USER_LOGIN ObjectName = "user_login"
	OBJECTNAME_USER_RECORD ObjectName = "user_record"
	OBJECTNAME_USER_RECORD_SUMMARY ObjectName = "user_record_summary"
	OBJECTNAME_TRANSITION_ELIGIBILITY ObjectName = "transition_eligibility"
	OBJECTNAME_WEBHOOK_ENDPOINT ObjectName = "webhook_endpoint"
)

// All allowed values of ObjectName enum
var AllowedObjectNameEnumValues = []ObjectName{
	"account",
	"api_token",
	"charge",
	"checkout_session",
	"checkout_session_item",
	"coupon",
	"credit_note",
	"credit_note_item",
	"customer",
	"customer_balance_transaction",
	"delivery_attempt",
	"discount",
	"dispute",
	"event",
	"invite",
	"invoice_item_discount",
	"invoice",
	"invoice_discount",
	"invoice_item",
	"payment_intent",
	"payment_link",
	"payment_link_line_item",
	"payment_method",
	"tokenized_card_payment_method",
	"payment_method_mapping",
	"payment_processor",
	"portal_session",
	"price",
	"price_tier",
	"product",
	"product_family",
	"promotion_code",
	"refund",
	"setup_intent",
	"subscription",
	"subscription_item",
	"tax_integration",
	"user",
	"user_login",
	"user_record",
	"user_record_summary",
	"transition_eligibility",
	"webhook_endpoint",
}

func (v *ObjectName) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := ObjectName(value)
	for _, existing := range AllowedObjectNameEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid ObjectName", value)
}

// NewObjectNameFromValue returns a pointer to a valid ObjectName
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewObjectNameFromValue(v string) (*ObjectName, error) {
	ev := ObjectName(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for ObjectName: valid values are %v", v, AllowedObjectNameEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v ObjectName) IsValid() bool {
	for _, existing := range AllowedObjectNameEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to ObjectName value
func (v ObjectName) Ptr() *ObjectName {
	return &v
}

type NullableObjectName struct {
	value *ObjectName
	isSet bool
}

func (v NullableObjectName) Get() *ObjectName {
	return v.value
}

func (v *NullableObjectName) Set(val *ObjectName) {
	v.value = val
	v.isSet = true
}

func (v NullableObjectName) IsSet() bool {
	return v.isSet
}

func (v *NullableObjectName) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableObjectName(val *ObjectName) *NullableObjectName {
	return &NullableObjectName{value: val, isSet: true}
}

func (v NullableObjectName) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableObjectName) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

